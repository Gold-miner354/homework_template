# 分治算法实验报告

## 学号：20201060354 

## 实验目的：

1、通过排序算法的程序实现和执行时间测试，与理论上的结论进行对比分析， 深入理解算法时间复杂度渐进性态和和增长率的概念；理解分治算法设计的基本 思想、递归程序实现的基本方法，加深对分治算法设计与分析思想的理解。

## 实验原理

1、算法时间复杂度分析的相关概念：算法的计算时间取决于算法中某些操作的执行次数，这些操作是算法时间复杂度分析的依据。增长率反映了算法的计算时间复杂度，即随着算法输入规模的增加、算法计算时间增加的趋势。算法的计算时间复杂度针对输入数据的等价类来分析或测试。  

2、随机数生成算法：通过程序生成（伪）随机数，作为实验用测试数据。该实验中使用了线性同余法：通过设置 Xi+1=(aXi+c) mod m, n0，其中的 4 个整数参数：m——模数, m>0； a——乘数, 0a<m。其中，种子数即X0使用系统时间作为种子通过srand函数生成，之后的随机数都采用线性同余法生成。  

3、分治算法的基本思想：将一个规模为 n 的问题分解为 k 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。分治算法设计的一般步骤包括： (1) 分解，将要解决的问题划分成若干规模较小的同类问题；(2) 求解，当子问题划分得足够小时，用较简单的方法解决； (3) 合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。  

4、分治法的基本设计范式如下：
![规模100000运行结果](./img/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F(%E4%BC%AA%E7%A0%81).png)

## 实验输入数据集

说明：该算法采用线性同余法生成(伪)随机数，唯一需要用户输入的是规模(10、100、1000、2000、5000、10000、100000……)，且由于数据集的规模庞大，在此不作展示，仅给出规模输入样例，具体生成的(伪)随机数可以运行源代码输入对应规模查看。

数据规模数据集：10、100、1000、2000、5000、10000、100000

## 实验内容
以冒泡排序、合并排序和快速排序算法为例，以生成的随机数作为实验中使用的测试数据。对每个算法，记录程序执行中随着测试数据增加算法基本操作执行次数，分析并以图形方式展现增长率；对以上三个排序算法，对比随着测试数据增加算法增长率变化趋势；测试、验证、对比算法时间复杂度的理论结论。  

1、“比较”是以上排序算法的基本操作（即决定算法执行效率的主要操作）， 在算法中设置比较操作的计数器，编程实现算法（输出最终的计数值）并进行测试，保证程序正确无误。  

2、使用随机数生成方法生成包含 100 个随机数的测试数据，记录这些数据， 并分别记录以上三个排序算法比较操作的执行次数；再重新生成包含 100 个随机 数的测试数据，记录这些数据三个排序算法比较操作的执行次数。 对比两次生成的测试数据和算法执行中比较操作的次数，理解算法复杂度分 析时输入数据等价类的含义。  

3、使用随机数生成方法生成不同规模的测试数据（10 个，100 个，1000 个， 2000 个，5000 个，10000 个，100000 个，……），对于每种规模的测试数据，分别记录BubbleSort、MergeSort 和 QuickSort 算法执行中比较操作的执行次数，使用 MS Excel、Matlab 或 Origin 等图表绘制工具生成随着输入数据增加、以上三个算法比较操作次数增加的对比曲线图（折线）。基于生成的曲线图，与时间复 杂度的理论结论对比分析，理解计算时间渐进性态和增长率的概念。  

4、在 MergeSort 和 QuickSort 算法中设置比较操作执行的全局计数器，编程实现算法（输出最终的计数值）；设置记录每次递归调用时描述问题规模的变量，程序结束时输出其值；通过测试保证程序正确无误，注意递归程序的实现、调试和测试。使用（3）中生成的测试数据（10 个，100 个，1000 个，2000 个，5000 个，10000 个，100000 个，……），对于每种规模的测试数据，分别记录以上两个算法执行中各子问题的规模，并用表格方式记录所有情形各子问题的规模值。

[DivideAndConquer.c](DivideAndConquer.c) 算法实现的C语言版本

## 实验预期结果与实际结果

### 实验预期结果

使用平均情况下三个算法的时间复杂度进行预测，则合并排序的时间复杂度为O(n*logn)，快速排序的时间复杂度为O(n*logn)，冒泡排序的时间复杂度为O(n2)，则三者的基本操作(比较)的次数也应该属于对应的时间复杂度。

### 实验过程及实验结果（C版）

规模10运行结果

![规模10运行结果](/img/%E8%A7%84%E6%A8%A110%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

规模100运行结果

![规模100运行结果](/img/%E8%A7%84%E6%A8%A1100%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

规模1000运行结果

![规模1000运行结果](/img/%E8%A7%84%E6%A8%A11000%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

规模2000运行结果

![规模2000运行结果](/img/%E8%A7%84%E6%A8%A12000%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

规模5000运行结果

![规模5000运行结果](/img/%E8%A7%84%E6%A8%A15000%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

规模10000运行结果

![规模10000运行结果](/img/%E8%A7%84%E6%A8%A110000%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

规模100000运行结果

![规模100000运行结果](/img/%E8%A7%84%E6%A8%A1100000%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)

三种排序算法的比较次数折线图

![比较次数折线图](/img/%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0%E6%8A%98%E7%BA%BF%E5%9B%BE.png)

两种分治算法的比较次数折线图

![两个分治算法的比较次数折线图](/img/%E4%B8%A4%E4%B8%AA%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0%E6%8A%98%E7%BA%BF%E5%9B%BE.png)

小数据下(由于从10000到100000跨度太大，折线图不直观，该图反映数据规模从10到10000区间内的变化)比较次数折线图

![小数据下比较次数折线图](/img/%E5%B0%8F%E6%95%B0%E6%8D%AE%E4%B8%8B%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0%E6%8A%98%E7%BA%BF%E5%9B%BE.png)

两种分治算法的子问题规模

![子问题规模表格](/img/%E5%AD%90%E9%97%AE%E9%A2%98%E8%A7%84%E6%A8%A1%E8%A1%A8%E6%A0%BC.png)